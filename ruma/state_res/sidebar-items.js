initSidebarItems({"enum":[["Error","Represents the various errors that arise when resolving state."]],"fn":[["auth_check","Authenticate the incoming `event`. The steps of authentication are:"],["auth_types_for_event","For the given event `kind` what are the relevant auth events that are needed to authenticate this `content`."],["get_auth_chain_diff","Returns a Vec of deduped EventIds that appear in some chains but not others."],["is_power_event",""],["is_power_event_id",""],["is_type_and_key",""],["iterative_auth_check","Check the that each event is authenticated based on the events before it."],["lexicographical_topological_sort","Sorts the event graph based on number of outgoing/incoming edges."],["mainline_sort","Returns the sorted `to_sort` list of `EventId`s based on a mainline sort using the depth of `resolved_power_level`, the server timestamp, and the eventId."],["resolve","Resolve sets of state events as they come in. Internally `StateResolution` builds a graph and an auth chain to allow for state conflict resolution."],["reverse_topological_power_sort","Events are sorted from “earliest” to “latest”."],["separate","Split the events that have no conflicts from those that are conflicting."]],"mod":[["event_auth",""],["room_version",""]],"struct":[["RoomVersion",""]],"trait":[["Event","Abstraction of a PDU so users can have their own PDU types."]],"type":[["EventMap","A mapping of `EventId` to `T`, usually a `ServerPdu`."],["Result","Result type for state resolution."],["StateMap","A mapping of event type and state_key to some value `T`, usually an `EventId`."]]});